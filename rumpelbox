#!/usr/bin/python3
#  !!!WARNING!!!! 
#
# This script is just a demonstrator of how pyrumpeltree works. The code in this file is nowhere close
# to being production ready. Most importantly, proper file locking and exception safety need to be
# seriously looked at if this code is to be used in production and error handling as a whole is basically missing.
# Next to that, the whole 'file in memory' operations stuff is seriously a bad idea for any operational usage.
# So remember, this script is just a demonstrator and have fun with using the pyrumpelree library.
#
import pyrumpeltree
import json
from os.path import expanduser,exists
from Crypto.Cipher import AES
from Crypto.Util import Counter
import os
import sys
import stat
import errno

class Repository:
  def _createdir(self,dirpath):
    if not exists(dirpath):
      self._createdir("/".join(dirpath.split("/")[:-1]))
      os.mkdir(dirpath)
  def _writedata(self,storage,data):
    relpath=storage() + ".dat"
    fek=storage.crypto_key()
    BS = 16
    padded=data + (BS - len(data) % BS) * chr(BS - len(data) % BS)
    ctr = Counter.new(128)
    cipher = AES.new(fek, AES.MODE_CTR, counter=ctr)
    ed=cipher.encrypt(padded)
    filepath=self.root + "/" + relpath
    self._createdir("/".join(filepath.split("/")[:-1]))
    f = open(filepath, 'wb')
    f.write(ed)
    f.close()
  def _readdata(self,storage):
    relpath=storage() + ".dat"
    fek=storage.crypto_key()
    BS = 16
    ctr = Counter.new(128)
    cipher = AES.new(fek, AES.MODE_CTR, counter=ctr)
    filepath=self.root + "/" + relpath
    f = open(filepath,'rb')
    ed=f.read()
    f.close()
    padded = cipher.decrypt(ed)
    return padded[:-ord(padded[len(padded)-1:])]
  def _unlink(self,storage):
    relpath=storage() + ".dat"
    filepath=self.root + "/" + relpath
    os.unlink(filepath)
  def _exists(self,storage):
    relpath=storage() + ".dat"
    filepath=self.root + "/" + relpath
    return exists(filepath)
  def _writeobject(self,storage,obj):
    data=json.dumps(obj)
    self._writedata(storage,data)
  def _readobject(self,storage):
    data=self._readdata(storage).decode('utf-8')
    return json.loads(data)
  def __init__(self,root,secret,cloudsecret=""):
    self.root=root
    self.rumpeltree = pyrumpeltree.create_server(secret,cloudsecret)
  def newroot(self,password=None):
    if password == None:
      rootcap=pyrumpeltree.randomrootcap()
    else:
      rootcap=pyrumpeltree.pass2rootcap(password)
    entity=self.rumpeltree[rootcap]
    storage=entity.storage()
    if self._exists(storage):
      print("Error: Node " + entity.cap() + " already excists")
    else:
      self._writeobject(storage,{'type':'dir','dir':[]})
      print("New root created; cap = ",entity.cap())
  def oldroot(self,password):
    rootcap=pyrumpeltree.pass2rootcap(password)
    entity=self.rumpeltree[rootcap]
    storage=entity.storage()
    if self._exists(storage):
      print(" * ",entity.cap())
    else:
      print("ERROR: No such entity currently exists.")
  def dumpdata(self,cap):
    entity=self.rumpeltree[cap]
    storage=entity.storage()
    if self._exists(storage):
      data=self._readdata(storage)
      print(data)
    else:
      print("ERROR: Entity does not exist")
  def restoredata(self,cap):
    entity=self.rumpeltree[cap]
    storage=entity.storage()
    if self._exists(storage):
      data=self._readobject(storage)
      if data["type"] != "file":
        print("ERROR: Node is not a data node")
      else:
        print(data["content"])
    else:
      print("ERROR: Entity does not exist")
  def ro(self,cap):
    entity=self.rumpeltree[cap]
    print(entity.attenuated().cap())
  def mkdir(self,cap,subdir):
    entity=self.rumpeltree[cap]
    if entity.isattenuated():
      print("Parent node is read only")
      return
    storage=entity.storage()
    parent=self._readobject(storage)
    if parent["type"] != "dir":
      print("Parent node isn't a directory")
      return
    for subent in parent["dir"]:
      if subent == subdir:
        print("Subdir exists already")
        return
    parent["dir"].append(subdir)
    self._writeobject(storage,parent)
    child=entity[subdir]
    cstorage=child.storage()
    self._writeobject(cstorage,{'type':'dir','dir':[]})  
    print(child.cap())
  def rmdir(self,cap,subdir):
    entity=self.rumpeltree[cap]
    if entity.isattenuated():
      print("Parent node is read only")
      return
    storage=entity.storage()
    parent=self._readobject(storage)
    if parent["type"] != "dir":
      print("Parenit node isn't a directory")
      return
    exists=False
    for subent in parent["dir"]:
      if subent == subdir:
        exists=True
    if exists == False:
      print("ERROR: No such entry.")
      return
    childentity = entity[subdir]
    storage2=childentity.storage()
    child=self._readobject(storage2)
    if child["type"] != "dir":
      print("ERROR: Child node isn't a directory")
      return
    if len(child["dir"]) != 0:
      print("ERROR: Child directory not empty.")
      return
    newdirlist=[]
    for subent in parent["dir"]:
      if subent != subdir:
        newdirlist.append(subent)
    parent["dir"]=newdirlist
    self._writeobject(storage,parent)
    self._unlink(storage2)
    print("OK")
  def rm(self,cap,subfile):
    entity=self.rumpeltree[cap]
    if entity.isattenuated():
      print("Parent node is read only")
      return
    storage=entity.storage()
    parent=self._readobject(storage)
    if parent["type"] != "dir":
      print("Parent node isn't a directory")
      return
    exists=False
    for subent in parent["dir"]:
      if subent == subfile:
        exists=True
    if exists == False:
      print("ERROR: No such entry.")
      return
    childentity = entity[subfile]
    storage2=childentity.storage()
    child=self._readobject(storage2)
    if child["type"] != "file":
      print("ERROR: Child node isn't a file")
      return
    newdirlist=[]
    for subent in parent["dir"]:
      if subent != subfile:
        newdirlist.append(subent)
    parent["dir"]=newdirlist
    self._writeobject(storage,parent)
    self._unlink(storage2)
    print("OK")

  def ls(self,cap):
    entity=self.rumpeltree[cap]
    storage=entity.storage()
    parent=self._readobject(storage)
    if parent["type"] != "dir":
      print("Parent node isn't a directory")
      return
    print("Directory node listing:")
    for subentname in parent["dir"]:
      subent=entity[subentname]
      print("* ",subentname,"=>",subent.cap())
  def save(self,cap,dataname):
    entity=self.rumpeltree[cap]
    if entity.isattenuated():
      print("Parent node is read only")
      return
    storage=entity.storage()
    parent=self._readobject(storage)
    if parent["type"] != "dir":
      print("Parent node isn't a directory")
      return
    for subent in parent["dir"]:
      if subent == dataname:
        print("File exists already")
        return
    parent["dir"].append(dataname)
    self._writeobject(storage,parent)
    child=entity[dataname]
    cstorage=child.storage()
    alldata = sys.stdin.read()
    self._writeobject(cstorage,{'type':'file','content': alldata})
    print(child.cap()) 
  def runfs(self, mp, fuse):
      class RumpelTreeFs(fuse.Fuse):
          def __init__(self,dash_s_do, version, usage, rt):
              self.rt = rt
              super(RumpelTreeFs, self).__init__(version=version, usage=usage, dash_s_do=dash_s_do)
          def main(self, args=None):
              fuse.Fuse.main(self, args)
          def _path_object(self, path):
              parts = path.split("/")[1:]
              try:
                  entity=self.rt[parts[0]]
                  storage=entity.storage()
              except:
                  return None,None,None
              epath = "~/.rumpeltree/" + storage() + ".dat"
              epath = os.path.expanduser(epath)
              fek=storage.crypto_key()
              BS = 16
              ctr = Counter.new(128)
              cipher = AES.new(fek, AES.MODE_CTR, counter=ctr)
              f = open(epath,'rb')
              ed=f.read()
              f.close()
              padded = cipher.decrypt(ed)
              plain = padded[:-ord(padded[len(padded)-1:])]
              if len(parts) > 1:
                  subent=entity[parts[1]].cap()
                  return json.loads(plain.decode('utf-8')), parts[1], subent
              else:
                  return json.loads(plain.decode('utf-8')), None, None
          def getattr(self, path):
              print("getattr", path)
              if path == "/":
                  st = os.lstat("/")
                  return st
              else:
                pobj,sub,cap = self._path_object(path)
                if pobj == None:
                    return -errno.ENOENT
                nodetype=pobj["type"]
                if nodetype == "dir":
                    if sub == None:
                        st = os.lstat("/")
                    else:
                        st = os.lstat("/etc/os-release")
                else:
                    st = os.lstat("/etc/passwd")
                return st
          def setattr(self, path, hmm):
              print("setattr", path)
              return 0
          def opendir(self, path):
              print("opendir", path)
              return 0
          def readdir(self, path, offset):
              print("READDIR:", path, offset)
              tags = ['.', '..']
              if path != "/":
                  pobj,sub,cap = self._path_object(path)
                  if pobj == None:
                      return -errno.ENOENT
                  for entry in pobj["dir"]:
                      tags.append(entry)
              return map(lambda k: fuse.Direntry(name = k, type = stat.S_IFDIR), tags)
          def releasedir(self, path):
              print("releasedir", path)
              return 0
          def readlink(self, path):
              print("readlink", path)
              pobj,sub,cap = self._path_object(path)
              return "../" + cap
          def listxattr(self, path, huh):
              print("listxattr", path)
              return 0
          def getxattr(self, path, name, size):
              print("getxattr", path)
              return 0
          def setxattr(self, path, name, val, more):
              print("setxattr", path)
              return 0
          def open(self, path, flags):
              print("open", path)
              return 0
          def release(self, path, fh):
              print("release", path)
              return 0
          def read(self, path, size, offset):
              print("read", path)
              return 0
          def write(self, path, data, offset):
              print("write", path)
              return 0
          def truncate(self, path, len, fh=None):
              print("truncate", path)
              return 0
          def flush(self, path):
              print("flush", path)
              return 0
      fs = RumpelTreeFs(version='%prog ' + '0.1.0', usage='RumpelTree FileSystem ' + fuse.Fuse.fusage, dash_s_do='setsingle', rt=self.rumpeltree)
      fs.parse(errex=1)
      fs.flags = 0
      fs.multithreaded = 0
      # Actually run the file system.
      fs.main()

home=expanduser("~")
rumpeldir=home + "/.rumpeltree"
if not exists(rumpeldir):
  print("Creating dir : '"+rumpeldir+"'")
  os.mkdir(rumpeldir)
repo=Repository(rumpeldir,b"sst,this is a secret")
me=os.path.basename(__file__)
if me == "rumpelbox":
  print("ERROR: Call rumpelbox through one of the symlinks")
elif me == "rumpeltreefs":
  try:
      import fuse
      fuse.fuse_python_api = (0, 2)
  except:
      print("ERROR: rumpeltreefs requires th python3 fuse module to be installed.")
      exit()
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Mount repo with at least one existing root directory as a file-system.")
    print("Usage:")
    print("   rumpeltreefs <mountpoint>")
    exit()
  if not os.path.isdir(sys.argv[1]):
      print("ERROR: invalid mountpoint given!")
      exit(1)
  if len(os.listdir(sys.argv[1]) ) != 0:
      print("ERROR: Mountpoint must be an empty directory!")
      exit(1)
  repo.runfs(sys.argv[1], fuse)
elif me == "rumpelnew":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Create a new root directory from a password.")
    print("Usage:")
    print("   rumpelnew <password>")
    exit()
  repo.newroot(sys.argv[1])
elif me == "rumpelold":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Reconstruct an existig rootdir using the same password used for its creation.")
    print("Usage:")
    print("   rumpelold <password>")
    exit()
  repo.oldroot(sys.argv[1])
elif me == "rumpeldump":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Dump the content of an existing Rumpelstiltskin Tree Node to standard out.")
    print("Usage:")
    print ("  rumpeldump <sparsecap>")
    exit()
  repo.dumpdata(sys.argv[1])
elif me == "rumpelrestore":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Dump the content of an existing Rumpelstiltskin Tree Node to standard out.")
    print("Usage:")
    print ("  rumpelrestore <sparsecap>")
    exit()
  repo.restoredata(sys.argv[1])
elif me == "rumpelro":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Get an attenuated (read only) version of any given unattenuated node.")
    print("Usage:")
    print("   rumpelro <rw sparsecap>")
    exit()
  repo.ro(sys.argv[1])
elif me == "rumpelmkdir":
  if len(sys.argv) < 3:
    print("Purpose:")
    print("   Create a new directory node as sub node of an existing unatenuated node.")
    print("Usage:")
    print("   rumpelmkdir <sparsecap> <dirname>")
    exit()
  repo.mkdir(sys.argv[1],sys.argv[2])
elif me == "rumpells":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   List all sub entities and their sparse caps for a given directory node.")
    print("Usage:")
    print("  rumpells <directory cap>")
    exit()
  repo.ls(sys.argv[1])
elif me == "rumpelrmdir":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Remove an empty subdirectory node.")
    print("Usage")
    print("  rumpelrmdir <parent dir cap> <subdir name>")
    exit()
  repo.rmdir(sys.argv[1],sys.argv[2])
  exit()
elif me == "rumpelrm":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("  Remove a data node.")
    print ("Usage:")
    print("  rumpelrm <parent dir cap> <data node name>")
    exit()
  repo.rm(sys.argv[1],sys.argv[2])
elif me == "rumpelsave":
  if len(sys.argv) < 2:
    print("Purpose:")
    print("   Save data from standard input to named data node.")
    print("Usage:")
    print("   <somecommand> | rumpelsave <directory cap> <new data node name>")
    exit()
  repo.save(sys.argv[1],sys.argv[2])
else:
    print("ERROR: Unknown symlink name:", me)

